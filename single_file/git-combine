#!/usr/bin/env python3
import argparse
import os
import subprocess
import sys


def verbose():
    return any(a in ('-v', '--verbose') for a in sys.argv)


def git(*cmd, **kwds):
    cmd = ('git',) + cmd
    if verbose():
        print('$', *cmd)
    out = subprocess.check_output(('git',) + cmd, **kwds)
    lines = out.decode('utf-8').splitlines()
    return (i for i in lines if i.strip())


def cd_git_root():
    cwd = os.getcwd()
    while not os.path.isdir('.git'):
        parent = os.path.dirname(os.getcwd())
        if parent == os.getcwd():
            os.chdir(cwd)
            raise ValueError('Not a git directory: %s' % cwd)
        os.chdir(parent)


def clean_workspace():
    try:
        return git('diff-index', '--quiet', 'HEAD', '--') or True
    except Exception:
        return False


def branches():
    return [b.strip().replace('* ', '') for b in git('branch')]


def current_branch():
    return next(git('symbolic-ref', '--short', 'HEAD')).strip()


def get_argv():
    return ['-h' if i == '--help' else i for i in sys.argv[1:]]


def print_help(argv, usage=None):
    argv[:] = ['-h' if i == '--help' else i for i in argv]
    if '-h' in argv:
        usage and print(usage)
        print()
        return True


def numeric_flags(argv, flag):
    for i in argv:
        if i.startswith('-') and i[1:].isnumeric():
            yield flag
            yield i[1:]
        else:
            yield i


def commit_count(add_arguments, usage=None, commit_count=4):
    argv = get_argv()
    print_help(argv, usage)

    parser = argparse.ArgumentParser()
    add_arguments(parser)
    parser.add_argument(
        '-c',
        '--commit-count',
        default=commit_count,
        help='Number of commits per branch to show',
        type=int,
    )

    return parser.parse_args(list(numeric_flags(argv, '-c')))


def run_argv(usage, main):
    argv = get_argv()
    if not print_help(argv, usage):
        main(*argv)


USAGE = """
git-combine: Combines multiple commit IDs together using cherry picking

Usage:
    git-combine <base-commit> [<additional-commit> ...<additional-commit>]
        [--force-push | -f] [--preserve-conflict | -p] [--stash | -s]


Hard-resets to <base-commit> then successively cherry-picks the additional
commit IDs on top

If the --force-push / -f flag is set, on successful completion the branch is
force-pushed using --force-with-lease.

If there are any uncommitted changes in the workspace ``git-combine`` will
fail, unless the --stash / -s flag is set, when uncommited changes are stashed.

By default, if there is an error in the cherry-picking, it is reported,
and then the branch gets reverted to where it was before ``git-combine``
started before the script errors... unless the --preserve-conflict / -p flag
is set, in which case the branch stays right at the broken cherry-pick.

Examples:
    git chp master d2dfe0c a2833bc
        Goes to the commit in `master` and then cherry picks the two commits
        d2dfe0c and a2833bc on top of it.

    git chp --force-push master d2dfe0c a2833bc
    git chp -f master d2dfe0c a2833bc
        The same, but force-push the result over the current branch
        (not master).

    git chp -p HEAD x-branch
    git chp --preserve-conflict HEAD x-branch
        Basically the same as ``git cherry-pick x-branch``

    git chp -s HEAD x-branch
        Something like ``git stash; git cherry-pick x-branch`` except that
        any changes are stashed, and if the cherry-pick fails, the state is
        reverted including the stash popped

"""

UNCOMMITTED_ERROR = """
Uncommitted changes would be overwritten.

(Use git combine --stash or -s to stash changes automatically)
"""


def git_combine():
    args = _parse_args()
    commit_id = _current_commit_id()
    stash = not clean_workspace()
    if stash:
        if not args.stash:
            raise ValueError(UNCOMMITTED_ERROR)
        _git('stash')
    try:
        _git('reset', '--hard', args.base[0])
        for id in args.commit_id:
            _git('cherry-pick', id)
        if args.force_push:
            _git('push', '--force-with-lease')
    except Exception:
        if not args.preserve_conflict:
            _git('reset', '--hard', commit_id)
            if stash:
                _git('stash', 'pop')
        raise


def _add_arguments(parser):
    add_arg = parser.add_argument
    add_arg('base', nargs=1, help='Base commit to combine from')
    add_arg('commit_id', nargs='+', help='List of commit IDs to cherry pick')

    boolean_flags = (
        ('force-push', 'Force push on success'),
        ('preserve-conflict', 'Do not revert the workspace on failure'),
        ('stash', 'Automatically stash any changes'),
        ('verbose', 'Report all git messages'),
    )
    for flag, help in boolean_flags:
        add_arg('-' + flag[0], '--' + flag, action='store_true', help=help)


def _current_commit_id():
    return next(git('rev-parse', 'HEAD')).strip()


def _git(*cmd, **kwds):
    for line in git(*cmd, **kwds):
        if verbose():
            print(line)


def _parse_args():
    argv = get_argv()
    print_help(argv, USAGE)

    parser = argparse.ArgumentParser()
    _add_arguments(parser)
    return parser.parse_args(argv)


if __name__ == '__main__':
    git_combine()
