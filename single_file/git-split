#!/usr/bin/env python3
import traceback

# Automatically generated on 2019-06-25 at 13:32:47 by _make_single_files
# DO NOT EDIT THIS FILE BY HAND
import argparse
import os
import subprocess
import sys


def verbose():
    return any(a in ('-v', '--verbose') for a in sys.argv)


def git(*cmd, **kwds):
    cmd = ('git',) + cmd
    if verbose():
        print('$', *cmd)
    out = subprocess.check_output(('git',) + cmd, **kwds)
    lines = out.decode('utf-8').splitlines()
    return (i for i in lines if i.strip())


def cd_git_root():
    cwd = os.getcwd()
    while not os.path.isdir('.git'):
        parent = os.path.dirname(os.getcwd())
        if parent == os.getcwd():
            os.chdir(cwd)
            raise ValueError('Not a git directory: %s' % cwd)
        os.chdir(parent)


def clean_workspace():
    try:
        return git('diff-index', '--quiet', 'HEAD', '--') or True
    except Exception:
        return False


def branches():
    return [b.strip().replace('* ', '') for b in git('branch')]


def current_branch():
    return next(git('symbolic-ref', '--short', 'HEAD')).strip()


def get_argv():
    return ['-h' if i == '--help' else i for i in sys.argv[1:]]


def print_help(argv, usage=None):
    argv[:] = ['-h' if i == '--help' else i for i in argv]
    if '-h' in argv:
        usage and print(usage)
        print()
        return True


def numeric_flags(argv, flag):
    for i in argv:
        if i.startswith('-') and i[1:].isnumeric():
            yield flag
            yield i[1:]
        else:
            yield i


def commit_count(add_arguments, usage=None, commit_count=4):
    argv = get_argv()
    print_help(argv, usage)

    parser = argparse.ArgumentParser()
    add_arguments(parser)
    parser.add_argument(
        '-c',
        '--commit-count',
        default=commit_count,
        help='Number of commits per branch to show',
        type=int,
    )

    return parser.parse_args(list(numeric_flags(argv, '-c')))


def run_argv(usage, main):
    argv = get_argv()
    if not print_help(argv, usage):
        main(*argv)


USAGE = """
git-split:  Split a range of commits into many single-file commits

`git-split` squashes together a range of commits and the staging area, then
splits out a sequence of individual commits, one for each file changed.

Usage:
    git-split
        Splits the staging area if it's not empty, otherwise HEAD

    git-split HEAD
        Splits the squash of the staging area and HEAD

    git-split HEAD~
        Splits the squash of the staging area, HEAD and HEAD~
"""


def git_split(commit=None):
    cd_git_root()

    if commit is not None:
        git('reset', commit + '~')
    elif clean_workspace():
        git('reset', 'HEAD~')

    splits = 0
    lines = git('status', '--porcelain')

    for line in lines:
        mode, filename = line.split(None, 1)

        # Renaming is a special case with two files on a line
        # separated by -> and with mode = '??'
        filenames = filename.split(' -> ')
        try:
            if mode == '??':
                git('add', *filenames)
            git('commit', '-m', '[split] %s' % filenames[0], *filenames)
            splits += 1

        except Exception:
            print('ERROR: couldn\'t commit filename %s.' % filename)
            traceback.print_exc()

    print('%d commit%s generated' % (splits, '' if splits == 1 else 's'))


if __name__ == '__main__':
    run_argv(USAGE, git_split)
