#!/usr/bin/env python3
from gitz import git_functions
from gitz import git_root
from gitz import reference_branch
from gitz.program import PROGRAM
from gitz.program import quiet_git

SUMMARY = 'Update branches from the reference branch'

DANGER = 'Rewrites history!'

HELP = """
``git update`` goes to each branch in turn, then tries to update it
the reference branch by pulling with --rebase.

If the rebase fails with a conflict, then ``git update``aborts the
rebase and returns that branch to its previous condition.

If the rebase succeeds, ``git update`` force-pushes the result.
"""

EXAMPLES = """
git update
    Updates all branches

git update foo bar
    Only updates branches foo and bar
"""


def git_update():
    git_root.check_clean_workspace()
    ref_branch = reference_branch.reference_branch()
    args = PROGRAM.args
    branches = git_functions.branches()
    missing = set(args.branches).difference(branches)
    if PROGRAM.error_if(missing, 'Missing'):
        PROGRAM.exit()

    starting_branch = git_functions.branch_name()
    failed, updated, unchanged = [], [], []

    progress = (lambda x: x) if PROGRAM.args.verbose else PROGRAM.message

    for branch in args.branches or branches:
        try:
            quiet_git.checkout(branch)
            cid = git_functions.commit_id()
            try:
                quiet_git.pull('--rebase', *ref_branch)
            except Exception:
                try:
                    quiet_git.rebase('--abort')
                except Exception:
                    pass
                raise

            if git_functions.commit_id() == cid:
                progress('(%s)' % branch)
                unchanged.append(branch)
            else:
                progress(branch)
                updated.append(branch)
            quiet_git.push('--force-with-lease')

        except Exception:
            failed.append(branch)

    PROGRAM.message()
    quiet_git.checkout(starting_branch)

    if updated:
        PROGRAM.message('Updated', *sorted(updated))

    if unchanged:
        PROGRAM.message('Unchanged', *sorted(unchanged))

    if PROGRAM.error_if(sorted(failed), 'Failed'):
        PROGRAM.exit()


def add_arguments(parser):
    parser.add_argument('branches', nargs='?', default='', help=_HELP_BRANCHES)
    parser.add_argument('-f', '--force', action='store_true', help=_HELP_FORCE)
    reference_branch.add_arguments(parser)


_ERROR_PUSH = 'Skipping {branch} which differed from {upstream}'
_HELP_FORCE = 'Force push over non-matching remote branches'
_HELP_BRANCHES = 'A list of branches to update - default is all branches'


if __name__ == '__main__':
    PROGRAM.start()
