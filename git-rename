#!/usr/bin/env python3
import _gitz

GIT = _gitz.GIT

USAGE = """\
git-rename:
    Renames a git branch locally and on all remotes

USAGE:
    git rename [<source-branch>] <target-branch>
"""

HELP = """
Renames one branch to another, both locally and in remote
branches.  If no source branch is given, the current branch is
used.

By default, the branches master and develop are not allowed to be
renamed.  This may be overridden by setting the environment
variable GITZ_PROTECTED_BRANCHES to a list of branches separated by
colons, or an empty string for no protected branches.

By default, any remote named upstream is skipped. This may be
overridden by setting the environment variable GITZ_PROTECTED_REMOTES
to a list of remotes separated by colons, or an empty string for no
protected remotes.

EXAMPLES:

    git rename eror error
        Rename the branch "eror" to "error" on both the local
        repository and any remote repositories where it appears
"""
PROGRAM = _gitz.GitProgram(USAGE, HELP)
_HELP_CREATE = 'Create remote branch if it does not exist'
_HELP_FORCE = 'Destructive rename over existing brances'


def _add_arguments(parser):
    add_arg = parser.add_argument
    add_arg('source', nargs=1)
    add_arg('target', nargs=1, default='')
    add_arg('-c', '--create', action='store_true', help=_HELP_CREATE)
    add_arg('-f', '--force', action='store_true', help=_HELP_FORCE)


def git_rename():
    args = PROGRAM.parse_args(_add_arguments)
    PROGRAM.require_clean_workspace()

    source = args.source if args.target else GIT.current_branch()
    target = args.target or args.source

    # branches = GIT.branches()

    PROGRAM.require_unprotected_branches(source, target)

    remotes = GIT.unprotected_remotes()
    for remote in remotes:
        GIT.fetch(remote)

    remote_branches = {}
    for rb in GIT.remote_branches().items():
        remote, branch = rb.split('/')
        if remote in remotes:
            remote_branches.setdefault(remote, []).append(branch)

    target, *rest = target.split('/', 1)
    remotes = rest and rest[0].split(':')

    actual_remotes = GIT.remote()
    bad_remotes = set(remotes).difference(actual_remotes)
    if bad_remotes:
        s = '' if len(bad_remotes) == 1 else 's'
        PROGRAM.error_exit('Bad remote%s:' % s, *bad_remotes)

    if not remotes:
        if len(actual_remotes) == 1:
            remotes = actual_remotes
        elif 'origin' in actual_remotes:
            remotes = ['origin']
        else:
            PROGRAM.error_and_exit('No remote repository specified')

    GIT.branch('-m', source, target)
    print('Moved /%s to /%s' % (source, target))
    for remote in reversed(remotes):
        GIT.push('--set-upstream', remote, target)
        print('Copied {0}/{1} to {0}/{2}'.format(remote, source, target))
        GIT.push(remote, ':' + source)
        print('Deleted {0}/{1}'.format(remote, source))


if __name__ == '__main__':
    git_rename()
