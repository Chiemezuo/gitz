#!/usr/bin/env python3
from _gitz import env
from _gitz import git
import _gitz

GIT = _gitz.GIT

USAGE = """\
git-rename:
    Renames a git branch locally and on all remotes

USAGE:
    git rename [<source-branch>] <target-branch>
"""

HELP = """
Renames one branch to another, both locally and in remote
branches.  If no source branch is given, the current branch is
used.

By default, the branches master and develop are not allowed to be
renamed.  This may be overridden by setting the environment
variable GITZ_PROTECTED_BRANCHES to a list of branches separated by
colons, or an empty string for no protected branches.

By default, any remote named upstream is skipped. This may be
overridden by setting the environment variable GITZ_PROTECTED_REMOTES
to a list of remotes separated by colons, or an empty string for no
protected remotes.

EXAMPLES:

    git rename eror error
        Rename the branch "eror" to "error" on both the local
        repository and any remote repositories where it appears
"""
PROGRAM = _gitz.GitProgram(USAGE, HELP)


def git_rename():
    args = PROGRAM.parse_args(_add_arguments)
    PROGRAM.require_clean_workspace()

    source = args.source if args.target else git.current_branch()
    target = args.target or args.source
    PROGRAM.require_unprotected_branches(source, target)

    protected = env.ENV.protected_remotes()
    existing, new = [], []
    for remote, branches in GIT.remote_branches().items():
        if remote not in protected:
            if target in branches and not args.force:
                if remote == GIT.LOCAL:
                    branch = target
                else:
                    branch = remote + '/' + target
                PROGRAM.error(_ERROR_TARGET_EXISTS % branch)
            elif source in branches:
                existing.append(remote)
            elif remote == GIT.LOCAL:
                PROGRAM.error(_ERROR_LOCAL_REPO, source)
            elif args.create:
                new.append(remote)

    if not args.force:
        commits = [git.commit_id('%s/%s' % (r, source)) for r in existing]
        if len(set(commits)) > 1:
            commits = [c[: git.COMMIT_ID_LENGTH] for c in commits]
            clist = ' '.join('='.join(rc) for rc in zip(remote, commits))
            PROGRAM.error(_ERROR_INCONSISTENT_COMMITS, clist)

    if PROGRAM.error_called:
        PROGRAM.exit()

    current = git.current_branch()
    force = ['--force-with-lease'] if args.force else []
    GIT.branch(*force, '-m', source, target)
    print('Moved /%s to /%s' % (source, target))
    GIT.checkout(target)

    for remote in existing + new:
        GIT.push(*force, remote, target)

    for remote in existing:
        try:
            GIT.push(remote, ':' + source)
        except Exception:
            PROGRAM.error(_ERROR_CANNOT_DELETE, remote)

    if current != source:
        GIT.checkout(current)


def _add_arguments(parser):
    add_arg = parser.add_argument
    add_arg('source', nargs=1)
    add_arg('target', nargs=1, default='')
    add_arg('-c', '--create', action='store_true', help=_HELP_CREATE)
    add_arg('-f', '--force', action='store_true', help=_HELP_FORCE)


_ERROR_CANNOT_DELETE = 'Cannot delete remote'
_ERROR_INCONSISTENT_COMMITS = 'Inconsistent commits IDs'
_ERROR_LOCAL_REPO = 'Branch %s does not exists in the local repository'
_ERROR_TARGET_EXISTS = 'Branch %s already exists'
_HELP_CREATE = 'Create remote branch if it does not exist'
_HELP_FORCE = 'Force rename over existing branches'


if __name__ == '__main__':
    git_rename()
