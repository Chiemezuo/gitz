#!/usr/bin/env python3
from gitz import git_functions
from gitz import program
from gitz import util
from gitz.git import GIT
import sys

USAGE = """\
git-all: Perform a command on each of multiple branches or directories

USAGE:
    git all [name ...] - <command> [argument ...]"""
HELP = """
Performs <command> [argument ...] for each `name`, or over all
branches if no `name` is given.

EXAMPLES:
    git all - git log --oneline -5
        Performs git log --oneline -5 for each branch in this repo

    git all * - git all - git log --oneline -5
        Performs git log --oneline -5 for each branch in each
        directory in athe current directory
"""

PROGRAM = program.Program(USAGE, HELP)


def git_all():
    argv = PROGRAM.argv
    dash = argv.index('-') if '-' in argv else len(argv)
    PROGRAM.argv, command = argv[:dash], argv[dash + 1 :]
    args = PROGRAM.parse_args(_add_arguments)

    if not command:
        PROGRAM.error_and_usage_and_exit(_ERROR_MISSING_COMMAND)
    if args.verbose:
        if args.quiet:
            args.verbose = False
            print('--quiet overrides --verbose', file=sys.stderr)
        else:
            GIT.verbose = True

    PROGRAM.check_git()
    branches = git_functions.branches() if util.find_git_root() else []
    names = args.name or branches

    if not args.dotfiles:
        names = [n for n in names if not n.startswith('.')]

    if set(branches).intersection(names):
        PROGRAM.check_clean_workspace()

    errors, names = [], []
    for name in args.name or branches:
        p = util.expand_path(name)
        if name in branches:
            names.append(name)
        elif not p.is_dir():
            errors.append(str(p))
        elif not p.name.startswith('.'):
            if args.all or util.find_git_root(p):
                names.append(str(p))

    if errors:
        errors = '"%s"' % '", "'.join(errors)
        PROGRAM.error_and_exit(_ERROR_BAD_NAME % errors)

    for name in names:
        try:
            _run_command(args, name, branches, command)
        except Exception as e:
            PROGRAM.error('Exception', e, 'for name', name)
            if not args.catch:
                PROGRAM.exit()


def _run_command(args, name, branches, command):
    if name in branches:
        if not args.quiet:
            print('Branch %s:' % name)
        saved_branch = git_functions.current_branch()
        GIT.checkout('-q', name)
        try:
            lines = util.run(*command)
        finally:
            GIT.checkout('-q', saved_branch)
    else:
        name = util.expand_path(name)
        if name.name.startswith('.'):
            return
        if not (args.all or util.find_git_root(name)):
            return
        if not args.quiet:
            print('Directory %s:' % name)
        lines = util.run(*command, cwd=str(name))
    indent = ' ' * args.indent
    for line in lines:
        print(indent, line, sep='')
    if not args.quiet:
        print()


def _add_arguments(parser):
    add = parser.add_argument
    add('name', nargs='*', help=_HELP_NAME)
    add('-c', '--catch', action='store_true', help=_HELP_CATCH)
    add('-d', '--dotfiles', action='store_true', help=_HELP_DOTFILES)
    add('-a', '--all', action='store_true', help=_HELP_ALL)
    add('-i', '--indent', default=2, type=int, help=_HELP_INDENT)
    add('-q', '--quiet', action='store_true', help=_HELP_QUIET)
    add('-v', '--verbose', action='store_true', help=_HELP_VERBOSE)


_ERROR_BAD_NAME = '%s: neither branch nor git repository'
_ERROR_MISSING_COMMAND = 'No command found'

_HELP_ALL = 'Visit non-git directories'
_HELP_CATCH = 'Instead of failing, catch and report errors, then continue'
_HELP_DOTFILES = 'Don\'t exclude dotfiles'
_HELP_FAIL = 'Fail immediately if any git-all command fails'
_HELP_INDENT = 'Number of columns to indent output of commands'
_HELP_NAME = 'Names of branches or directories to iterate over'
_HELP_QUIET = 'Print only command output and errors, no git or git-all output'
_HELP_VERBOSE = 'Echo all git commands and their responses'

if __name__ == '__main__':
    git_all()
