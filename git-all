#!/usr/bin/env python3
from pathlib import Path
import argparse
import sys
import _gitz

USAGE = """
git-all: Perform a command on each of multiple branches or directories

USAGE:
    git all [name ...] - <command> [argument ...]

Performs <command> [argument ...] for each `name`, or over all branches if no
`name` is given.

EXAMPLES:
    git all - git log --oneline -5
        Performs git log --oneline -5 for each branch in this repo

    git all * - git all - git log --oneline -5
        Performs git log --oneline -5 for each branch in each directory in
        the current directory

"""

GIT = _gitz.GIT
EXIT = _gitz.Exit(USAGE)


def git_all():
    argv = sys.argv[1:]

    try:
        dash = argv.index('-')
    except ValueError:
        EXIT.exit_if_help(argv)
        EXIT.exit('No - found in arguments')

    argv, command = argv[:dash], argv[dash + 1 :]
    if not command:
        EXIT.exit('No command found after - in arguments')

    args = _parse_args(argv)

    branches = GIT.branches() if GIT.find_root() else []
    names = args.name or branches
    assert not names or isinstance(names[0], str), str(names)

    if not args.dotfiles:
        names = [n for n in names if not n.startswith('.')]

    if set(branches).intersection(names) and GIT.is_workspace_dirty():
        EXIT.exit('Your local changes would be overwritten')

    errors = [n for n in names if not (n in branches or Path(n).is_dir())]
    if errors:
        errors = '"%s"' % '", "'.join(errors)
        EXIT.exit(errors + ':', 'neither branch nor git repository')

    for name in names:
        try:
            if name in branches:
                print('Branch', name)
                saved_branch = GIT.current_branch()
                GIT.checkout('-q', name)
                try:
                    lines = _gitz.run(*command)
                finally:
                    GIT.checkout('-q', saved_branch)
            else:
                print('Directory', name)
                lines = _gitz.run(*command, cwd=name)
            indent = ' ' * args.indent
            for line in lines:
                print(indent, line, sep='')
            print()

        except Exception as e:
            EXIT.error('Exception', e, 'for name', name)
            if not args.catch:
                EXIT.exit(print_usage=False)


def _parse_args(argv):
    parser = argparse.ArgumentParser(description=USAGE)
    add = parser.add_argument

    add('name', nargs='*', help=_NAME_HELP)
    add('-d', '--dotfiles', action='store_true', help=_DOTFILES_HELP)
    add('-c', '--catch', action='store_true', help=_CATCH_HELP)
    add('-i', '--indent', default=2, type=int, help=_INDENT_HELP)

    return parser.parse_args(['-h' if a == '--help' else a for a in argv])


_DOTFILES_HELP = 'Don\'t exclude dotfiles'
_CATCH_HELP = 'Instead of failing, catch and report errors, then continue'
_INDENT_HELP = 'Number of columns to indent output of commands'
_NAME_HELP = 'Names of branches or directories to iterate over'


if __name__ == '__main__':
    git_all()
